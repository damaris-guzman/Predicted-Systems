<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Attention Ecosystem</title>
  <link rel="stylesheet" href="style.css">
    <style>
      html,body{height:100%;margin:0}
      body{background:#070707;color:#eee;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
      canvas{display:block}
      .ui{position:fixed;left:12px;top:12px;color:#cfcfcf;z-index:10}
      .help{position:fixed;right:12px;top:12px;color:#9aa;z-index:10;font-size:13px}
      .tooltip{position:fixed;padding:8px 10px;border-radius:6px;background:rgba(0,0,0,0.75);color:#fff;font-size:13px;pointer-events:none;z-index:20;display:none}
    </style>
  </head>
  <body>
  <a class="home-link" href="swag.html" title="Home"><img src="images/earth.gif" alt="Home"></a>
    <div class="ui">Mode: <strong id="modeLabel">Category</strong> (press C to toggle)</div>
    <div class="help">Hover cells for details. Click to pin info.</div>
    <div id="tooltip" class="tooltip"></div>
    <canvas id="ctx"></canvas>

    <script>
    // Attention Ecosystem v2
    // - Two domains: 'type' (ad type) and 'why' (why clicked/emotion)
    // - Each ad becomes two nodes (type node + why node) linked by adId
    // - Same-domain merging follows the current grouping mode (C to toggle)
    // - Cross-domain: when a type node meets its linked why node they converge into a glossy cylinder

    const canvas = document.getElementById('ctx');
    const ctx = canvas.getContext('2d');
    let W = canvas.width = innerWidth;
    let H = canvas.height = innerHeight;
    window.addEventListener('resize', ()=>{W=canvas.width=innerWidth;H=canvas.height=innerHeight});

    // sample ad data (replaceable) — each will produce a type-node and a why-node
    const sampleAds = [
      // existing sample items
      {name:'Synthwave Live', category:'Music', emotion:'Spectacle', reason:'Clicked for concert dates'},
      {name:'Indie Night', category:'Music', emotion:'Curiosity', reason:'Looks like friends are going'},
      {name:'Rave Poster', category:'Music', emotion:'Spectacle', reason:'Bold colors stood out'},
      {name:'Minimal Jacket', category:'Fashion', emotion:'Nostalgia', reason:'Reminds me of an old fave'},
      {name:'Streetwear Drop', category:'Fashion', emotion:'Spectacle', reason:'Limited edition hype'},
      {name:'Green Cafe', category:'Food', emotion:'Curiosity', reason:'Wanted to try the menu'},
      {name:'Cocktail Bar', category:'Food', emotion:'Nostalgia', reason:'Looks familiar'},
      {name:'Design Tablet', category:'Tech', emotion:'Curiosity', reason:'Useful for sketching'},
      {name:'Creative Suite', category:'Tech', emotion:'Spectacle', reason:'Promised crazy features'},
      {name:'Community Help', category:'Causes', emotion:'Nostalgia', reason:'Moved by the story'},
      {name:'Local Service', category:'Services', emotion:'Curiosity', reason:'Needed quick support'},
      {name:'Misc Offer', category:'Misc', emotion:'Spectacle', reason:'Bright discount badge'},
      // user-provided music examples
      {name:'Ghost', category:'Music', emotion:'Consumption', reason:'Consumption / Interest + Visually Appealing'},
      {name:'5n0w_', category:'Music', emotion:'Consumption', reason:'Consumption / Interest'},
      {name:'CRE2K', category:'Music', emotion:'Consumption', reason:'Consumption / Interest + Visually Appealing'},
      {name:'YUNG LEAN — Fox Theater 10/11 Oakland', category:'Music', emotion:'Curiosity', reason:'Experience / Curiosity'},
      {name:'Purity Ring — Warfield Oct 14', category:'Music', emotion:'Curiosity', reason:'Experience / Curiosity + Visually Appealing'},
      {name:'ARTMS — Monterey show', category:'Music', emotion:'Interest', reason:'Experience / Interest'},
      {name:'Coachella', category:'Music', emotion:'Interest', reason:'Experience / Interest'},
      {name:'WENDY 1st WORLD TOUR — Golden Gate Theatre Oct 30', category:'Music', emotion:'Curiosity', reason:'Experience / Curiosity'},
      {name:'✧ATARAXIA : VERTIGO✧ (Temple SF)', category:'Music', emotion:'Curiosity', reason:'Experience / Curiosity'}
    ];

    const typeColors = {Music:'#ff4d6d',Fashion:'#7b61ff',Food:'#ffb84d',Tech:'#4dd2ff',Causes:'#61ff8a',Services:'#ffd36b',Misc:'#bfbfbf'};
    const whyColors = {
      Curiosity:'#ffd36b',
      Nostalgia:'#7b61ff',
      Spectacle:'#ff5f2e',
      Consumption:'#66e0a3',
      Interest:'#ffd36b',
      Experience:'#8ec1ff',
      'Visually Appealing':'#ff9ad1'
    };

    const emotionShapes = {
      Curiosity:'triangle',
      Nostalgia:'diamond',
      Spectacle:'star',
      Consumption:'square',
      Interest:'dot',
      Experience:'triangle',
      'Visually Appealing':'star'
    };

    // nodes include both type and why nodes
    let nodes = [];
    let cylinders = []; // created when linked nodes converge

    function createNodesFromAds(){
      nodes = [];
      for(let i=0;i<sampleAds.length;i++){
        const ad = sampleAds[i];
        const x = Math.random()*W, y = Math.random()*H;
        // type node
        nodes.push({id: `type-${i}`, adId:i, domain:'type', x:x + (Math.random()*40-20), y:y + (Math.random()*40-20), vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6, r:12 + Math.random()*6, baseR:12, data:ad});
        // why node
        nodes.push({id: `why-${i}`, adId:i, domain:'why', x:x + (Math.random()*40-20), y:y + (Math.random()*40-20), vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6, r:10 + Math.random()*6, baseR:10, data:ad});
      }
    }
    createNodesFromAds();

    let grouping = 'category'; // 'category' or 'emotion'
    const modeLabel = document.getElementById('modeLabel');

    // value-noise-like function
    function noise2(x,y){return (Math.sin(x*12.9898 + y*78.233) * 43758.5453) % 1}

    // glossy circle draw
    function drawGlossyCircle(x,y,r,color,domain){
      // base radial gradient
      const g = ctx.createRadialGradient(x - r*0.3, y - r*0.4, r*0.1, x, y, r);
      g.addColorStop(0, lighten(color,0.2));
      g.addColorStop(0.5, color);
      g.addColorStop(1, darken(color,0.18));
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      // glossy highlight
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,255,255,0.28)';
      ctx.beginPath(); ctx.ellipse(x - r*0.28, y - r*0.4, r*0.5, r*0.32, -0.5, 0, Math.PI*2); ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      // subtle rim
      ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
    }

    function drawInnerShape(x,y,r,shape){
      ctx.fillStyle = '#070707';
      if(shape==='dot'){ ctx.beginPath(); ctx.arc(x,y,Math.max(2,r*0.18),0,Math.PI*2); ctx.fill(); }
      else if(shape==='square'){ const s = Math.max(4,r*0.28); ctx.fillRect(x-s/2,y-s/2,s,s); }
      else if(shape==='triangle'){ const s = Math.max(6,r*0.36); ctx.beginPath(); ctx.moveTo(x,y-s/2); ctx.lineTo(x-s/2,y+s/2); ctx.lineTo(x+s/2,y+s/2); ctx.closePath(); ctx.fill(); }
      else if(shape==='diamond'){ const s = Math.max(6,r*0.32); ctx.beginPath(); ctx.moveTo(x,y-s/2); ctx.lineTo(x-s/2,y); ctx.lineTo(x,y+s/2); ctx.lineTo(x+s/2,y); ctx.closePath(); ctx.fill(); }
      else if(shape==='star'){ const s = Math.max(6,r*0.28); drawStar(x,y,s,5); }
    }

    function drawStar(cx,cy,outer,Rpoints){
      const spikes = Rpoints||5; const outerRadius = outer; const innerRadius = outer*0.45;
      let rot = Math.PI/2*3; let x = cx; let y = cy; let step = Math.PI/spikes;
      ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
      for(let i=0;i<spikes;i++){
        x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x,y); rot += step;
        x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x,y); rot += step;
      }
      ctx.closePath(); ctx.fill();
    }

    function lighten(hex, amt){ const c = hexToRgb(hex); return `rgba(${Math.min(255,c.r+Math.round(255*amt))},${Math.min(255,c.g+Math.round(255*amt))},${Math.min(255,c.b+Math.round(255*amt))},1)` }
    function darken(hex, amt){ const c = hexToRgb(hex); return `rgba(${Math.max(0,c.r-Math.round(255*amt))},${Math.max(0,c.g-Math.round(255*amt))},${Math.max(0,c.b-Math.round(255*amt))},1)` }
    function hexToRgb(hex){ const h = hex.replace('#',''); return {r:parseInt(h.substring(0,2),16), g:parseInt(h.substring(2,4),16), b:parseInt(h.substring(4,6),16)} }

    // draw cylinder between two positions with thickness
    function drawCylinder(ax,ay,bx,by,thickness,colorA,colorB,scale=1){
      const dx = bx-ax, dy = by-ay; const len = Math.hypot(dx,dy);
      if(len < 0.1) return;
      const ux = dx/len, uy = dy/len;
      const midx = (ax+bx)/2, midy = (ay+by)/2;
      const w = Math.max(12, thickness*scale);
      // compute perpendicular
      const px = -uy, py = ux;
      // corners of rectangle
      const x1 = ax + px*w/2, y1 = ay + py*w/2;
      const x2 = ax - px*w/2, y2 = ay - py*w/2;
      const x3 = bx - px*w/2, y3 = by - py*w/2;
      const x4 = bx + px*w/2, y4 = by + py*w/2;
      // body gradient
      const grad = ctx.createLinearGradient(ax,ay,bx,by);
      grad.addColorStop(0, colorA); grad.addColorStop(1, colorB);
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.lineTo(x4,y4); ctx.closePath(); ctx.fill();
      // draw caps (ellipses) for 3D look
      ctx.save(); ctx.translate(ax,ay); ctx.rotate(Math.atan2(dy,dx));
      const capGradA = ctx.createLinearGradient(-w,0,w,0); capGradA.addColorStop(0,lighten(colorA,0.08)); capGradA.addColorStop(1,darken(colorA,0.12));
      ctx.fillStyle = capGradA; ctx.beginPath(); ctx.ellipse(0,0,w/2,w/3,0,0,Math.PI*2); ctx.fill(); ctx.restore();
      ctx.save(); ctx.translate(bx,by); ctx.rotate(Math.atan2(dy,dx));
      const capGradB = ctx.createLinearGradient(-w,0,w,0); capGradB.addColorStop(0,lighten(colorB,0.08)); capGradB.addColorStop(1,darken(colorB,0.12));
      ctx.fillStyle = capGradB; ctx.beginPath(); ctx.ellipse(0,0,w/2,w/3,0,0,Math.PI*2); ctx.fill(); ctx.restore();
      // highlight along body
      ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo((x2+x3)/2,(y2+y3)/2); ctx.lineTo((x1+x4)/2,(y1+y4)/2); ctx.closePath(); ctx.fill(); ctx.globalCompositeOperation='source-over';
    }

    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y) }

    // step update
    function step(dt){
      const t = performance.now()*0.00012;
      // nodes wander
      for(let n of nodes){
        const nx = noise2(n.x*0.007, n.y*0.007 + t);
        const ny = noise2(n.x*0.007 + 5.1, n.y*0.007 + t + 3.3);
        n.vx += (nx-0.5)*0.06; n.vy += (ny-0.5)*0.06;
        n.vx *= 0.96; n.vy *= 0.96;
        n.x += n.vx * dt; n.y += n.vy * dt;
        if(n.x < n.r) { n.x = n.r; n.vx *= -0.6 }
        if(n.x > W - n.r) { n.x = W - n.r; n.vx *= -0.6 }
        if(n.y < n.r) { n.y = n.r; n.vy *= -0.6 }
        if(n.y > H - n.r) { n.y = H - n.r; n.vy *= -0.6 }
      }

      // handle collisions
      for(let i=0;i<nodes.length;i++){
        for(let j=i+1;j<nodes.length;j++){
          const a = nodes[i], b = nodes[j];
          const d = dist(a,b);
          if(d < a.r + b.r - 1){
            if(a.domain !== b.domain){
              // cross-domain: if same ad, form cylinder
              if(a.adId === b.adId){
                // create cylinder and remove nodes
                cylinders.push({adId:a.adId, ax:a.x, ay:a.y, bx:b.x, by:b.y, t:performance.now(), scale:0});
                nodes.splice(j,1); nodes.splice(i,1); j--; break;
              } else {
                // just bounce
                const nx = (b.x - a.x)/d, ny = (b.y - a.y)/d;
                const p = 2*(a.vx*nx + a.vy*ny - b.vx*nx - b.vy*ny)/(a.r + b.r);
                a.vx = a.vx - p * b.r * nx; a.vy = a.vy - p * b.r * ny;
                b.vx = b.vx + p * a.r * nx; b.vy = b.vy + p * a.r * ny;
                const overlap = (a.r + b.r) - d; const sep = overlap/2 + 0.5;
                a.x -= nx*sep; a.y -= ny*sep; b.x += nx*sep; b.y += ny*sep;
              }
            } else {
              // same domain: merge if grouping key matches
              const keyA = (grouping === 'category') ? a.data.category : a.data.emotion;
              const keyB = (grouping === 'category') ? b.data.category : b.data.emotion;
              if(keyA === keyB){
                // merge smaller into larger
                const larger = a.r >= b.r ? a : b; const smaller = a.r >= b.r ? b : a;
                // weighted average
                const total = larger.baseR + smaller.baseR;
                larger.x = (larger.x*larger.baseR + smaller.x*smaller.baseR)/total;
                larger.y = (larger.y*larger.baseR + smaller.y*smaller.baseR)/total;
                larger.vx = (larger.vx + smaller.vx)/2; larger.vy = (larger.vy + smaller.vy)/2;
                larger.baseR = Math.min(120, larger.baseR + Math.round(smaller.baseR*0.8));
                larger.r = Math.min(120, larger.baseR + 6);
                nodes.splice(nodes.indexOf(smaller),1);
                j--; i = Math.max(0,i-1);
              } else {
                // bounce
                const nx = (b.x - a.x)/d, ny = (b.y - a.y)/d;
                const p = 2*(a.vx*nx + a.vy*ny - b.vx*nx - b.vy*ny)/(a.r + b.r);
                a.vx = a.vx - p * b.r * nx; a.vy = a.vy - p * b.r * ny;
                b.vx = b.vx + p * a.r * nx; b.vy = b.vy + p * a.r * ny;
                const overlap = (a.r + b.r) - d; const sep = overlap/2 + 0.5;
                a.x -= nx*sep; a.y -= ny*sep; b.x += nx*sep; b.y += ny*sep;
              }
            }
          }
        }
      }

      // update cylinders (grow scale)
      for(let c of cylinders){
        const elapsed = (performance.now() - c.t)/600; c.scale = Math.min(1, elapsed);
      }
    }

    // rendering
    function render(){
      ctx.clearRect(0,0,W,H);
      // cylinders behind nodes
      for(let c of cylinders){
        const ad = sampleAds[c.adId];
        const colorA = typeColors[ad.category] || '#999';
        const colorB = whyColors[ad.emotion] || '#777';
        drawCylinder(c.ax, c.ay, c.bx, c.by, 24, colorA, colorB, c.scale);
      }
      // nodes
      for(let n of nodes){
        const color = (n.domain==='type') ? (typeColors[n.data.category]||'#999') : (whyColors[n.data.emotion]||'#999');
        drawGlossyCircle(n.x,n.y,n.r,color,n.domain);
        // inner shape for why nodes
        if(n.domain==='why') drawInnerShape(n.x,n.y,n.r, emotionShapes[n.data.emotion] || 'dot');
        // small label for type nodes
        if(n.domain==='type'){
          ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='10px Arial'; ctx.textAlign='center'; ctx.fillText(n.data.category, n.x, n.y + n.r + 12);
        }
      }

      // tooltip
      if((hovered||pinnedInfo) && (hovered||pinnedInfo).x!=null){
        const info = pinnedInfo || hovered;
        const t = document.getElementById('tooltip');
        t.style.display = 'block';
        t.style.left = (info.x + 18) + 'px'; t.style.top = (info.y + 18) + 'px';
        t.innerHTML = `<strong>${info.data.name}</strong><div style="font-size:12px;margin-top:6px;opacity:.95">${info.data.reason}</div><div style="font-size:11px;margin-top:6px;color:#9aa">${info.data.category} • ${info.data.emotion}</div>`;
      } else {
        document.getElementById('tooltip').style.display = 'none';
      }
    }

    // interaction
    let hovered = null, pinnedInfo = null;
    window.addEventListener('mousemove', (ev)=>{
      const x = ev.clientX, y = ev.clientY; hovered = null;
      // check nodes
      for(let n of nodes){ if(Math.hypot(n.x-x,n.y-y) < n.r + 6) { hovered = n; break; } }
      // check cylinders (midpoint)
      if(!hovered){ for(let c of cylinders){ const mx=(c.ax+c.bx)/2, my=(c.ay+c.by)/2; if(Math.hypot(mx-x,my-y) < 28) { hovered = {x:mx,y:my,data:sampleAds[c.adId],isCylinder:true}; break; } } }
    });
    window.addEventListener('click', ()=>{ if(hovered) pinnedInfo = pinnedInfo===hovered?null:hovered; });

    // toggle grouping and rebuild nodes
    window.addEventListener('keydown', (ev)=>{
      if(ev.key.toLowerCase() === 'c'){
        grouping = grouping === 'category' ? 'emotion' : 'category';
        modeLabel.textContent = grouping.charAt(0).toUpperCase() + grouping.slice(1);
        // rebuild nodes (split existing merged nodes)
        createNodesFromAds(); cylinders = [];
      }
    });

    // main loop
    let last = performance.now();
    function loop(){
      const now = performance.now();
      const dt = Math.min(32, now-last)/16; last = now;
      step(dt); render(); requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // helpers: color math already above
    </script>
  </body>

  <!-- custom cursor banner (uses style from style.css) -->
  <div class="cursor-banner">
    <a href="https://www.totallyfreecursors.com/" target="_blank" class="tfc" rel="noopener noreferrer">
      <img src="https://downloads.totallyfreecursors.com/public/CursorsLogo88-31.gif" border="0" width="88" height="31" alt="Free Box Question Pink Glitter Cursors at www.totallyfreecursors.com" />
    </a>
  </div>
</html>
